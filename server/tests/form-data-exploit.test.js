// server/tests/form-data-exploit.test.js
import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import supertest from 'supertest';
import { startServer } from '../../server/server.js';
import path from 'path';
import { fileURLToPath } from 'url';
import fs from 'fs';
import { jest } from '@jest/globals';
import jwt from 'jsonwebtoken';
import { getCurrentSigningKey } from '../../server/keyManager.js';

// Mock the dependencies
jest.mock('../../server/keyManager.js', () => ({
    getCurrentSigningKey: () => ({ privateKey: 'test-private-key', kid: 'test-kid' }),
    getJwks: () => ({ keys: [] }),
    rotateKeys: () => {},
}));
jest.mock('../../server/bot.js', () => ({
    initializeBot: () => ({ telegram: { sendMessage: () => {} } }),
}));
jest.mock('../../server/email.js', () => ({
    sendEmail: () => {},
}));

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

describe('Form-Data Vulnerability Exploit', () => {
    let server;
    let request;
    let authToken;
    let csrfToken;
    let cookies;

    beforeAll(async () => {
        const testDBPath = path.join(__dirname, 'test-db.json');
        if (fs.existsSync(testDBPath)) fs.unlinkSync(testDBPath);

        const { app } = await startServer(null, null, null, testDBPath);
        server = app.listen(0);
        request = supertest(server);

        // --- Authentication ---
        // 1. Get CSRF token and session cookies
        const csrfResponse = await request.get('/api/csrf-token');
        csrfToken = csrfResponse.body.csrfToken;
        cookies = csrfResponse.headers['set-cookie'];

        // 2. Create a valid JWT for an admin user
        const { privateKey, kid } = getCurrentSigningKey();
        authToken = jwt.sign(
            { email: process.env.ADMIN_EMAIL, username: 'admin' },
            privateKey,
            { algorithm: 'RS256', expiresIn: '1h', header: { kid } }
        );
    });

    afterAll((done) => {
        const testDBPath = path.join(__dirname, 'test-db.json');
        if (fs.existsSync(testDBPath)) fs.unlinkSync(testDBPath);
        server.close(done);
    });

    test('should fail to parse a request with a predictable multipart boundary', async () => {
        // A vulnerable version of `form-data` might parse this, leading to a 400 Bad Request
        // because the 'designImage' field is expected but not correctly parsed.
        // A patched version should handle the boundary differently, likely resulting in a
        // more direct "stream ended unexpectedly" or similar parsing error, also a 400.
        // The key is that the server should reject this malformed request.
        const response = await request
            .post('/api/upload-design')
            .set('Cookie', cookies)
            .set('Authorization', `Bearer ${authToken}`)
            .set('X-CSRF-Token', csrfToken)
            .set('Content-Type', 'multipart/form-data; boundary=--------------------------123456789012345678901234')
            // This is a malformed body that a vulnerable library might misinterpret
            .send(`--myboundary\r\nContent-Disposition: form-data; name="field1"\r\n\r\nvalue1\r\n--myboundary--`)
            .expect(500);

        expect(response.status).toBe(500);
    });
});
